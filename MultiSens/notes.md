#Notes on implementing my multi-sensory stimulation protocol using the existing ArduFSM framework

##Part 1: Background on multisens_hw_control

multisens_hw_control is the program that I developed for presenting multiple Arduino-controlled sensory stimuli stimultaneosly. As of 160413, this program is saved on the "polymorphism" branch of my git repo multisens_hw_control, which I maintain at:

https://github.com/danieldkato/multisens_hw_control/tree/polymorphism

As described here, it appears to be working well enough in a few test cases that I'm satisfied with the feasibility of the general idea, and I'm now thinking about how to merge it into the existing ArduFSM framework.

The basic idea is that I need to be able to control multiple devices from an Arduino simultaneously (or nearly simultaneously) throughout the course of a stimulus presentation. I will also have to control some devices, like monitors, independently of the Arduino, but I can deal with that on the Python side of things - one thing that is clear is that I will AT LEAST have to control multiple devices near-simultaneously through an Arduino. 

###The naive approach:
For some stimuli, like brushing a pole through the whisker field, it is sufficient to issue some kind of "on" and "off" command (or "extend" and "retract," in this case) at the beginning and end of the stimulus period, respectively. 

###The problem with the naive approach: some devices may require constant updating
However, some stimuli may require constant updating throughout the stimulus period. One example of this is generating a white noise stimulus. While it would be convenient for me to somehow pre-load a white noise pattern at the beginning of the stimulus period then have the Arduino execute it over its duration, this is not the way Arduino's Tone library works. 

Rather, every time I want the tone generated by the speaker to change, the script must change the value of a tone variable associated with a Tone object, then call that Tone object's `play` command at the time that I want the actual sound coming out the speaker to change. Since I want the tone to be changing as close to constantly as possible, the sketch needs to be constantly making calls to Tone throughout the duration of the stimulus period. The same would be true if I wanted to generate any other acoustic stimulus as a function of time, like an exponential chirp, etc. 

###The naive approach redux: different while loops for each condition
Given these specific considerations, the most straightforward solution might be to just have steppers extend and retract at the beginning and end of each stimulus period, then have the tone constantly updating in a while loop that lasts for the duration of the stimulus period in between. 

Further, for each stimulus condition,  I could write a separate `while` loop. Then, during experiments, Python could supply the Arduino with a condition index on every trail, then have it decide which `while` loop to execute based on this index. In fact, this is what I currently do. 

###The problem with the naive approach redux: too many while loops
However, this solution will not generalize well. What if I want to add additional devices, like another stepper, or another solenoid? The number of different conditions I'd have to write would grow exponentially whenever I add devices to the Arduino. Supposing I have a stepper, a speaker, and a solenoid, and that I have only two states ("on" or "off") for each, I'd have to write 2^3  = 8 separate `while` loops. This is tractable enough, but if I wanted to add   another stepper, I'd have to write 2^4 = 16 different `while` loops. If I wanted to add another solenoid on top of that, I'd have to write 2^5 = 32 different `while` loops. Hard-coding these would be error prone, redundant, and would fundamentally fail to reflect the underlying logic that each device's state should be, in principle, independently manipulable.     

###A more flexible approach: object-oriented programming
One flexible way to solve this problem would be to make use of object-oritented programming, described here:

https://learn.adafruit.com/multi-tasking-the-arduino-part-1 

where different devices controlled by an Arduino are represented by objects that each have their own `update` function that is a function of time. On each pass of `loop`, each object's `update` function is called. 

For my purposes, `update` can be a function of some index that dictates what state one particular device should be in, and Python can supply such an index for each device on every trial. It can also be a function of time. So I like this object-oriented approach.

###An even more flexible approach: removing object instantiation from the main sketch
However, for my purposes, there is another shortcoming of the example linked to above. In it, `loop` refers to a fixed set of objects. This means that every time I want to change what devices are controlled by the Arduino, I would have to change the contents of `loop`. Since I may be making frequent changes to which devices are controlled by the Arduino (say between experiments running different conditions), this seems error-prone. 

It would be better if I could separate out the stuff that never has to change and save that in a main sketch that almost never gets tampered with, and then take those settings that are more likely to change on an experiment-by-experiment basis and then save those off in separate configuration files that can be specified at the beginning of each experiment. 

I've accomplished this by creating config.h and config.cpp, which are separate from the main sketch. They define a function called `config_hw`, which returns an array of device objects, each of which has their own `update` function. I can keep different config.h and config.cpp files for different experiment configurations, then somehow specify which one to use at the beginning of each experiment. 

The main sketch calls `config_hw` at the beginning of the file before `setup` or `loop` are called. This creates` devPtrs`, an array of pointers to device objects, in the global scope of the main sketch. Each pass of `loop` corresponds to a trial, and for the duration of the each trial, the sketch repeatedly iterates through devPtrs and calls each device's `update` function using `devPtrs->update`. As discussed above, `update` can be a function of some index that Python supplies for each device on the current trial, as well as of time.  

There are two constraints imposed by the above strategy that are worth noting. First, in order for all devices to be put in the same array, they must inherit from the same class. Thus, I have a parent `Device` class from which I derive specific classes for each device type like `Stepper`, `Speaker`, `Solenoid`, etc. 

Second, in order to use `->update` for each device in the array, `update` must be a virtual function of the parent class that is then defined for each child class. This means that for each child device class, `update` must have the same signature - i.e., it must take the same number and type of inputs, and must return the same type of output. In this context where `update` has different definitions in sibling classes, it is said to have the property of polymorphism. 

For the time being, `update` takes 4 arguments: a condition index, a start time, a stop time, and the time the trial started.This allows one to specify a device's behavior between an on time and an off time for any number of conditions. I'm not certain that this is the best signature, but it will serve my purposes for now. For testing purposes, each device class also has a `ping` function that just reports back its name. 

###The status quo:
So far, I have a test program that: 

1) defines, instantates and returns an array of device object pointers in a separate configuration file defining a `config_hw` function, 

2) creates an array of device object pointers devPtrs by calling `config_hw` from the main sketch 

3) on each trial, for the duration of a trial, iterates through devPtrs and calls each device's `ping` function. 

This test program works (at least at baud rates of 9600 and 115200), which leads me to conclude that an object-oriented, polymorphic approach can work.



##Part 2: ArduFSM
  
Now the question is how to take these strategies and implement them in the existing ArduFSM framework. The ArduFSM framework includes more functionality than I currently need, so it might be acceptable to just take a very pared-down version of ArduFSM and merge it with multisens_hw_control somehow. However, it's conceivable that I might ultimately want to start testing more sophisticated behaviors, in which case it may be more of a hassle to have to build out functionality by merging successive portions of ArduFSM piecewise; every round of this kind of expansion requires figuring out which pieces of ArduFSM can be merged independently of each other. Thus, it may be worthwhile to figure out how much ArduFSM functionality can be merged now without unacceptable amounts of superfluous functionality. This section will include an overview of the ArduFSM framework as well as a detailed, step-by-step explanation of how one example protocol might work.

###Organizational overview
The ArduFSM framework is encapsulated in a git repository available at:

https://github.com/cxrodgers/ArduFSM.git

ArduFSM is used for running a number of distinct behavioral protocols, some of which are specific to particular behavioral rigs. At the top level, the ArduFSM repository includes a number of python scripts shared by all protocols; these are for things like scheduling trials, communicating serial data to and from the Arduino, and plotting the animal's performance. I'm likely to make use of chat.py for communicating to and from the Arduino, but I will probably have to write my own top-level Python scripts for scheduling trials; the existing scripts are very specific to Chris' behavior, and don't accomodate for having to control a monitor in parallel with an Arduino.

Next to these top-level Python scripts are a number of directories. One of these directories is a library containing Arduino sketches and C++ source code for use in every behavioral protocol, like Arduino functions for reading data from the serial port, detecting contacts from an MPR121 capacitative touch sensor, as well as classes for executing certain timed actions (like rotating a stepper or waiting for a behavioral response).

*One outstanding question: if I downlad ArduFSM as a subdirectory of an existing Arduino sketchbook (for exmaple, on a computer that already has other Arduino sketches), can this libraries folder stay in ArduFSM? Or do its contents have to be moved to the pre-existing sketchbok's library?*     

The other directories on ArduFSM correspond to individual protocols, which, again, are in some cases specific to a particular behavioral rig. Each one of these protocol directories includes a main Python script, a main Arduino sketch, rig-specific hardware constants, and source code defining some protocol-specific classes for executing times actions (again, like rotating a stepper or waiting for a behavioral response).

Since my computer-side Python code will probably have to change substantially in any case, let's start off by looking at the Arduino code and seeing how much we can conserve. 

At the heart of the main Arduino sketch for any given protocol is a switch case statement nested within `loop`. The `switch case` statement evaluates a variable called `current_state`, and for any given value of `current_state`, it executes a particular block of code (much like an if/then statement). Importantly, the code within each case is and should be something that can execute quickly, i.e. on a millisecond time scale, so that each pass of `loop` can complete as quickly as possible (this means making only sparing use of the `delay` command, which stops the Arduino from doing anything else for the duration of the delay period). Making each pass of `loop` as fast as possible allows the program to perform certain regular actions at a very high frequency, like check for licks.

To illustrate in more detail how this works, let's go through how a typical trial in the TwoChoice protocol might be executed:

###Step-by-step description of how ArduFSM TwoChoice protocol works

At the beginning of every trial, the variable `current_state` is initialized to `WAIT_TO_START_TRIAL`, and `flag_start_trial` is intialized to `false`.    

The sketch starts its pass of `loop`, which begins by getting the current time. There follows a series of static declarations - ignore these for now. The variable `next_state` is by default set equal to `current_state`. 

####Comminucate with the computer
`loop` then calls a function called `communications`, defined in chat.h and chat.cpp in ArduFSM/libraries, to receive any new input from the computer and take appropriate action. Notably, `communications` doesn't actually return any messages it receives in the normal, "formal" way (e.g., the way a function like `int sum(int x, int y)` would return an `int`), so much of how the Arduino responds to serial input is dictated by code either within or called by `communications` itself. Thus, it's worth examining in some detail how `communications` works.  

`communications` parses input from the serial port into three `char` arrays, namely, a command and two arguments. The command can either be `"ACT"` or `"SET"`. If the command is `"ACT"`, then the first argument is some function abbreviation that maps on to a function (like giving a reward) through a dispatch table; the second argument is made blank. If the command is `"SET"`, then the first arugment is some trial parameter abbreviation, and the second argument is the value of that parameter. 

It begins by defining empty (i.e., `""`) `char` arrays for `protocol_cmd`, `argument1` and `argument2`. It also defines a `char` pointer `received_chat`, which will later essentially store any received messages from the computer.  

It then calls a function called `receive_chat`, which is defined in the same library. `receive_chat` reads characters off of the Arduino one by one and puts them in a `char` array until it receives a newline (`'\n'`) character. Because arrays are not a legal return type in C++, `receive_chat` just returns a pointer to the first element of the received `char` array. In C++, a pointer to the first element of an array can be treated just like an array itself using the syntax `pointer[index]`. This returned pointer becomes the value of `received_chat`, which can now be treated as a `char` array (i.e., a string).     

`communcations` then calls `handle_chat`, also defined in the same library. This function parses `received_chat` into separate words, but, again, does so without actually returning anything. Here is how. First, `handle_chat` takes pointers to `received_chat`, `protocol_cmd`, `argument1` and `argument2` as input arguments. It then goes through `received_chat`, finds any spaces, then splits up received_chat into up to three `char` arrays (thus, each `char` array represents a single word). 

Then, for each one of these words, it calls `strncpy`. `strncpy` is a function from the `cstring` library, which  is included in Arduino.h by default. `strncpy` takes a `char` array and a pointer, then copies the `char` array to the variable pointed to by the pointer. In this case, the `char` array is a single word from `received_chat`, and the pointer is one of the pointers that `handle_chat` took as an argument - i.e., to `protocol_cmd`, `argument1` or `argument2`. Thus, for each word, `strncpy` copies the word to one of the variables `protocol_cmd`, `argument1` or `argument2`. Recall that these variables were originally defined outside of `handle_chat` itself, at the beginning of `communications`; this means that `communications` will have access to the `char` data copied over to these variables, even though `handle_chat` hasn't actually formally returned anything to `communications`.       

In addition to parsing the received chat, `handle_chat` checks if the received chat includes a partcular special message: `"RELEASE_TRL"`. If so, `handle_chat` takes a special action beyond just parsing the message that, unlike everything described in the chat library so far, affects variables outside the scope of the library. `handle_chat` changes the value of the `boolean` variable `flag_start_trial` to 1. `flag_start_trial` is a variable that is defined and initialized to 0 in the main sketch, and used to signal when the FSM can begin executing the trial. Because `flag_start_trial` is not actually defined in the chat library, it has be declared `extern` at the beginning of chat.cpp, meaning that it is defined in another ("external") file, namely, the main sketch.    

`communications` then calls `take_action`, which takes appropriate actions given `command`, `argument1` and `argument2`. Unlike the other functions called so far by `communications`, it is declared in chat.cpp as `extern`, meaning that it is not actually defined in chat.cpp itself; rather, it is defined in another ("external") file. In this case, that file is the main sketch, which defines `take_action` after the `main loop` code. The reason for this is that `take_action` is used to update trial parameters, and thus must be able to refer to the arrays `param_abbrevs` and `param_values`, which store the parameter abbreviations used by the computer and the current trial parameters, respectively. However, these arrays are not defined in ArduFSM/libraries/chat because they are protocol-specific, and as a general-purpose library used across protocols, chat should not depend on protocol-specific code; we don't want to have to worry about changing #include statements in chat every time we run a new protocol. Instead, `take_action` is defined in the main sketch, where `param_values` and `param_abbrevs` are declared (albeit "extern" as will be discussed later).

*But why is take_actions defined in the main sketch rather than in States.cpp?*           

*Also, how does this even work? The main sketch includes States.h, but States.h doesn't declare param_values; rather, param_values is defined in States.cpp. param_values is declared extern at the beginning of the main sketch, but isn't actually defined in any of the included code, so how does a function in the main sketch access param_values?*

`take_actions` then essentially implements the if statement described when we first introduced `communications`: if command is `"ACT"`, then it uses `argument1` as an index to a function, and if command is `"SET"`, then it uses `argument1` as a parameter abbreviation and `argument2` as a parameter value, then writes the value to the parameter by searching the param_abbrevs for a match with `argument1`, saving the index, then writing the value of `argument2` to `param_values[index]`.     

So much for how `communications` works. Now let's go back out to `loop`, and suppose that `communications` has not detected any serial input from the computer on this pass.   

####Check for licks
Now, we check for any licks by calling `pollTouchInputs`, defined in ArduFSM/libraries/mpr121. Checking for licks is something that we want to do very frequently, as we want to monitor the animal's behavior as closely as possible. This is why we want the code on each pass of `loop` to execute quickly; so that we can reach this point on the subsequent pass of `loop` to check for licks again as soon as possible.   

*What data type exactly is touched?*
*What is this sticky_touched business?*

####Wait to start the trial
Now we get to the `switch case` statement. Recall that `current_state` is initialized to `WAIT_TO_TRIAL_START`, so the switch case statement executes the code in the corresponding block. This case consists entirely of an `if` statement that only executes if `flag_start_trial` is `true`. `flag_trial_start` is set to its default value of `false`, so the sketch goes straight to the `break` line, which exits the `switch case` statement. 

After the `switch case` statement, the sketch updates the value of `current_state` to the value of `next_state`. Since the value of `next_state` was set to be the same as the value of `current_state` at the beginning of `loop`, and since the value of `next_state` was not changed over the course of `loop`, the value of `current_state` remains unchanged. The sketch then begins another iteration of `loop` with `current_state` equal to `WAIT_TO_TRIAL_START`, and the cycle begins again. 

This cycle repeats itself until `communications` detects that the message `"RELEASE_TRL"` has been received. When this happens, `handle_chat` sets `flag_trial_trial_start` to `true`. Now, when the sketch reaches the `switch case` statement, the sketch will still execute the same case (because `current_state` is still `WAIT_TO_START_TRIAL`), but this time `flag_trial_start` is `true`, so the Arduino executes the code inside the `if` statement. The code inside the `if` statement sets `next_state` to `TRIAL_START`, then the sketch exits the `switch case` statement. Now, when `current_state` takes on the value of `next_state`, `current_state` gets updated to `TRIAL_START`. 

Thus, when the sketch reaches the switch case statement on the next iteration of `loop`, the Arduino will execute the code in the `TRIAL_START` case. This dims the house lights, prints the current trial parameters over the serial port, updates the trial parameters and resets the timers of all trial-related state objects [using a syntax I don't understand??], then sets `next_state` to `ROTATE_STEPPER1`.

From now on, the heart of every case in the `switch case` statement will be constituted by one of two types of function: non-class functions and class functions. Non-class functions are for performing actions that can be completed on one pass of `loop`, i.e., on the order of milliseconds, while the class functions are for controlling behavior that must persist over multiple passes of `loop`, e.g., task epochs that last on the order of seconds. All of these functions are declared in States.h and defined in States.cpp, which accompany the main sketch in the TwoChoice protocol folder.  

####Rotate the stepper: an example of a **_non-class_** function
Consider for example the current case we are on, `ROTATE_STEPPER1`. This case consists entirely of a call to one function: `state_rotate_stepper1`. This is an example of a non-class function, and because many non-class functions share the same syntax, it's worth examining in more detail how this function works.

`state_rotate_stepper1` takes `next_state` as its sole argument, but it does so in a special way. Note the ampersand in the function signature - this indicates that the function takes `next_state` "by reference", which means that the value of `next_state` can be changed within the function itself. By contrast, when functions take a variable the more common way - i.e., "by value" rather than "by reference" - they are actually just *copying the value of* the input variable into the scope of the function, and cannot affect the original variable itself (such functions are only be able to return a value to whatever program called it, and the calling program itself must assign that returned value to the variable it wants to update). 

*Why do these non-class functions take next_state by reference?*

`state_rotate_stepper1` accepts `next_state` by reference, then makes a stepper rotate some number of steps. It gets the number of steps to rotate from the array `param_values`, which, as mentioned above, stores the parameter values for the current trial. `param_values` is defined in the global scope of States.cpp, so `state_rotate_stepper1` will have access to it (recall that all state functions are also defined in States.cpp). `state_rotate_stepper1` then calls a custom function `rotate`, also defined in States.cpp, which takes the number of steps to rotate as an input argument. `rotate` in turn takes an instance of the class `Stepper` and calls its `step` function. The `Stepper` class is defined in the standard Arduino library Stepper.h, and the particular `Stepper` instance is created in the main sketch; the reference to the particular instance in States.cpp is permitted because it is declared `extern` at the beginning of the file. After rotating the stepper, `state_rotate_stepper1` updates the value of `next_state` to `INTER_ROTATION_PAUSE`.     

*Once again, how does the extern reference actually work? The main sketch that instantiates the stepper object is not actually included in States.cpp. Can variables declared extern be defined in ANY linked file? And if so, what actually constitutes a linked file? I need to better understand the basic logic of how extern declarations work.*     

This is the basic template for how many of the non-class functions work: they take `next_state` by reference, do something fast, then update `next_state`. 

####Wait between rotations: an example of a **_class_** function
This brings us to the case `INTER_ROTATION_PAUSE`, which illustrates the other main type of function: the class functions, which are used for dictating the Arduino's behavior throughout the course of task epochs that persist over multiple passes of `loop`. The case `INTER_ROTATION_PAUSE` consists entirely of a call to the class function `state_interrotation_pause.run`. Like the non-class functions, the class functions share much of the same syntax, so it's worth understanding this example in more detail. 

In this example, `run` is a function belonging to the object `state_interrortation_pause`, which is an instance of the class `StateInterRotationPause`. The individual instance `state_interrotation_pause` is created in the main sketch, and the class `StateInterRotationPause` is declared in States.h and defined in States.cpp. `StateInterRotationPause` inherits in turn from the class `TimedState`, which is declared in ArduFSM/libraries/TimedState. This means that `state_interrotation_pause` is itself a `TimedState` object, meaning that it has all of the variables and functions defined in the `TimedState class`. All of the objects invoked in the class function states are `TimedState` objects.  

At the core of every `TimedState` object is a public function called `run`, which is called at most once on each pass of the `switch case` statement and takes the current time as its sole argument. Every `TimedState` object also has, among other things, a variable called `timer`, which is by default set to 0. The behavior of `run` depends on the relationship between timer and the current time.   

If `timer` is equal to 0 (i.e., the default value), this means that that the task epoch monitored by `run` has not yet begun. In this scenario, `run` calls another `TimedState` class function called `s_setup`. By default, this function does nothing, but because it is a virtual function, it can be redefined in any class that inherits from `TimedState` (i.e., it is polymorphic). This is done in the definition of the "child" class in States.cpp. In the particular case of `StateInterRotationPause`, `s_setup` is *not* redefined, so it retains its default definition of doing nothing. After calling `s_setup`, `run` adds the intended duration of the current task epoch to the current time to obtain the appropriate end time of the current task epoch; this becomes the new value of `timer`, and on subsequent calls to `run` during the current task epoch, the fact that `timer` is greater than 0 will signal that the task epoch has already begun. 

If `timer` is greater than the current time, this means that we're in the middle of the task epoch monitored by `run`. In this scenario, `run` calls the `TimedState` class function `loop` - this is not to be confused with the main `loop` function in the global scope of the main sketch! Like `s_setup`, `loop` does nothing by default but is polymorphic and can be redefined for each class that inherits from `TimedState`. This really constitutes the core of what the Arduino is doing throughout the duration of the task epoch. In the particular case of StateInterRotationPause, however, we want the Arduino to do nothing throughout the course of the task epoch, so `loop` is not redefined.  

If the current time is greater than `timer`, this means that the task epoch monitored by `run` is over. `run` calls the `TimedState` class function `s_finish`, which, like `s_setup`, does nothing by default but is polymorphic and can be defined for each class that inherits from TimedState. `timer` is also reset to 0. `s_finish` is often used to advance `next_state`. Like the non-class functions, the class functions can update `next_state` without returning anything. Unlike the non-class functions, they don't even take `next_state` by reference; rather, `next_state` is declared as `extern` in States.cpp (to be later defined and initialized in the main sketch). In the particular case of `StateInterRotiationPause`, `s_finish` advances next_state to `ROTATE_STEPPER2`.

####Rotate stepper 2
On the next pass of `loop`, the Arduino will execute the code in the case `ROTATE_STEPPER2`. This calls the non-class function `state_rotate_stepper2(next_state)`, which, like the previous non-class function example, just rotates a stepper then advances `next_state`, this time to` MOVE_SERVO`.

####Move the servo
On the next pass of `loop`, the Arduino will execute the case `MOVE_SERVO`. Like the `INTER_ROTATION_PAUSE` case, this case relies on class functions. Unlike `INTER_ROTATION_PAUSE`, however, this case calls *two* distinct class functions from the main sketch : `state_wait_for_servo_move.update` and `state_wait_for_servo_move.run`, where `state_wait_for_servo_move` is an instance of the class `StateWaitForServoMov`e (`which, again, inherits from TimedState`). We've already seen how `run` works, so let's take a look at `update`. 

Like `s_setup` and `s_finish`, `update` is declared as a virtual function in the declaration of `TimedState`, so it can be redefined for any class that inherits from `TimedState` (by default it does nothing). This function is typically used for updating private variables. In this particular case, for example, when the class `StateWaitForServoMove` is declared in States.h, it declares a private variable called `my_linServo` (in addition to all of the variables that it inherits from `TimedState`). Then, in States.cpp, `StateWaitForServoMove`'s version of `update` is re-defined; it now takes a `Servo` object (from the standard Arduino Servo library) as its argument and sets that `Servo` object as the value of the private variable `my_linServo`. As `state_wait_for_servo_move` is an instance of this class, it is the actual individual object that has the variable `my_linServo` and  

*How is the changing signature of TimedState.update allowed?*     


As in the previous example, `state_wait_for_servo_move.run` sets `timer` then governs the Arduino's behavior throughout the duration of the task epoch. In this case, it opens the left or right reward valve (depending on the trial parameters given in `param_values`) 500ms before the end of the task epoch . Once the task epoch is complete, the `timer` is reset to 0 and `next_condition` set to `RESPONSE_WINDOW`.

*why is reward given in the move servo epoch??*

####Get responses from the mice and give reward accordingly
On the next pass of `loop`, the Arduino executes the case `RESPONSE_WINDOW`, another class function state. Unlike in the previous cases, the `next_case` here is not predetermined; rather, it will depend on feedback from the mouse. This calls `srw.update` and `srw.run`, where `srw` is an instance of `StateResponseWindow`. `srw.run` checks which reward pipe the mouse is licking and writes the results to the `results_values` array. 

If the mouse does not ever respond, the trial is scored as `NOGO` and next_state advances to `INTER_TRIAL_INTERVAL` (described in more detail below).  

If the mouse responds incorrectly, `next_state` is advanced to `ERROR`. This is a class function case that calls `state_error_timeout.run`, where `state_error_timeout` is an instance of the `StateErrorTimeout` class. `state_error_timout.run` does nothing for the duration of a timeout period then advances `next_state` to `INTER_TRIAL_INTERVA`L.  

If the mouse responds correctly, `next_state` is advanced to `REWARD_L` or `REWARD_R`. These are non-class function cases that call `state_reward_r` or `state_reward_l`, respectively, which simply dispense a reward then advance `next_state` to `POST_REWARD_PAUSE`. 

`POST_REWARD_PAUSE` is a class function case that calls `state_post_reward_pause.run(time)`, where `state_post_reward_pause` is another `TimedState` object. This cycles the state *back* to `RESPONSE_WINDOW`. As long as the mouse continues to respond correctly, this cycle will continue until either a) the the response window elapses or b) the mouse receives the maximum number of rewards. In either case, `next_state` will advance to `INTER_TRIAL_INTERVA`L. This is a class function case that calls `state_inter_trial_interval.run`, which reports the trial results back to the computer, does nothing for the duration of the intertrial interval, then advances `next_state` to `WAIT_TO_START_TRIAL`. Now we're back where we started, with `current_state` set to `WAIT_TO_START_TRIAL` and `flag_start_trial` set to `false` (which happened immediately after the last trial was released), and the cycle repeats again.

So much for TwoChoice; this should illustrate how the FSM works in general.


 

##Question recap:

*One outstanding question: if I downlad ArduFSM as a subdirectory of an existing Arduino sketchbook (for exmaple, on a computer that already has other Arduino sketches), can this libraries folder stay in ArduFSM? Or do its contents have to be moved to the pre-existing sketchbok's library?*     


*Do the non-class functions state_rotate_stepper1, etc., ever get used? It seems not*

*But why is take_actions() defined in the main sketch rather than in States.cpp?*           

*Also, how does this even work? The main sketch includes States.h, but States.h doesn't declare param_values; rather, param_values is defined in States.cpp. param_values is declared extern at the beginning of the main sketch, but isn't actually defined in any of the included code, so how does a function in the main sketch access param_values?*

*What data type exactly is touched?*
 
*What is this sticky_touched business?*

*Why is the extern declaration for next_state in States.cpp rather than States.h?*

*Why do these non-class functions take next_state by reference?*

*Once again, how does the extern reference actually work? The main sketch that instantiates the stepper object is not actually included in States.cpp. Can variables declared extern be defined in ANY linked file? And if so, what actually constitutes a linked file? I need to better understand the basic logic of how extern declarations work.* 

*How is the changing signature of TimedState.update() allowed?*    

*why is reward given in the move servo epoch??*

___
*TimedState.loop() might be a reasonable place to iterate through devPtrs; that is, for the duration of the stimulus epoch, the switch case statement will call the run() function of some TimedState object corresponding to the stimulus epoch. This in turn will call that TimedState object's loop() function, each call of which will iterate once through the devPtrs array and call each device's Device.update() function. devPtrs can be instantiated in the global scope of States.cpp so it can be accessed from any TimedState's loop() function.*

*Some issues to think about if I do it this way:*

*Will this require an extern declaration of devPtrs in the main sketch? It seems that putting devPtrs in the global scope of States.cpp would preclude the need for this, which would be preferable; that is, all referneces to devPtrs would be made from within States.cpp, so defining devPtrs within its global scope should be enough, and no declaration of devPtrs should be necessary in the main sketch. But param_values is also declared in the global scope of States.cpp and for some reason has an extern declaration in the main sketch. Why is this? It seems to be because there are multiple references to param_values in the main sketch itself, e.g. in setup(), in loop() when initializing timed state objects and in the switch case statement when echoing trial parameters back to the computer. If, by contrast, there will be no references to devPtrs in the main sketch itself, then maybe the extern declaration isn't necessary. (Also, relatedly, this makes me wonder if some of these functions that use param_values can be moved to States.cpp). *

*My Device.update() functions currently take a number of arguments, including a condition index, a start time, a stop time and the time of the trial start. How will Device.update() get these arguments from inside TimedState.loop()? I can't have TimedState.loop() take those parameters as input arguments then pass them to Device.update(), because TimedState.loop() doesn't take any input arguments in its signature. I could change its signature, but because it's a polymorphic function, this would also change its signature in every other class that inherits from TimedState, which seems excessive.*  
         
*Perhaps the parameters could be (private) fields of the TimedState object that manages the stimulus epoch. This TimedState object could then also have its own function that takes some arguments from param_values then assigns their values to the private parameter fields, which are then referred to in Device.update() when it is called from TimedState.loop().*     

*NOTE: On further inspection, Chris appears to have a similar strategy whereby the private parameters of a TimedState object are changed via a TimedState.update() function. Puzzlingly, however, this function's signature in TimedState seems to be different from its signature in inheriting classes. I didn't think this was allowed??*              
___                                          
*Some ideas on possible improvements:* 

*Currently, all of the TimedState objects are declared static at the beginning of loop(), and the timers are reset (using a syntax I don't understand) in the TRIAL_START switch case statement. This involves manually listing every TimedState object.* 

*Would it be better if we could move references to individual TimedState objects to States.cpp? For example, rather than instantiating each one at the beginning of loop(), they could be instantiated in States.cpp, then we could have an function returning them in an array to the main sketch (like I do with devPtrs). Moreover, in the States source code, we could define indexes into the TimedState object array using macros, so that way all references to particular TimedState objects in the main sketch can be replaced with something like TimedStateArray[INDEX].*

*Also, in order to reset the timers on the TimedState objects, each object could have a resetTimer() function, and during the TRIAL_START switch case statement, the sketch could iterate through TimedStateArray and call each object's resetTimer() function.*

/////////////////////////////////////////////////////
So, if I want to pilot my own FSM, what states and parameters do I need?

States:
WAIT_FOR_TRIAL_START - doesn't require any functions
TRIAL_START - doesn't require any functions
STIM_PERIOD - class 
REWARD - non-class [can just never invoke for experiments without reward]
RESPONSE WINDOW - class [can just never invoke for experimejnts without reward]
ERROR - class [didn't think this was necessary, but may be necessary for shaping behavior so mouse isn't just licking to everything]
INTER-TRIAL INTERVAL - class 
POST_REWARD_PAUSE - class

param_vals:
stepper function index
speaker function index
overall stim duration
rewarded or not
reward duration

If I'm going to be giving reward, I might want to make reward coterminous with stimulus. in this case, does it make sense to make solenoid just another device like stepper and speaker? And like stepper and speaker, it can have an on time and an off time, and that on time can be a few hundred ms before the end of the overall stimulus period? 

Alternatively, doesn't the existing code already do something like start to deliver reward before the end of the stimulus period?

response_values:
whether or not it responded (can be binary for one pipe)
whether ot not this was a correct response (i.e, )


##Update 160505: A usable version of my multisensory stimulus protocol is now implemented in ArduFSM/MultiSens. I've run it in conjunction with testMultiSens160504, and verified that it works in the output file testMultiSens_output160504. 

Remaining issues: In a departure from existing protocols, I've decided to make reward delivery coterminous with the stimulus. Now I need to decide how to deal with errors.

I suppose having a timeout makes sense because I don't want the animal licking indiscriminately to everything; I want to know that the mouse specifically associates reward with a particular stimulus condition, so I think a timeout may be necessary for shaping behavior. 

But under what specific conditions should the timeout be introduced? Right now, the existing TwoChoice protocol only transitions into the timeout state if the animal makes a false alarm approach during the response window, which follows the stimulus period. Since my rewards will be coterminous with the stimulus period, however, might I expect some licking during the stimulus period itself? And if so, should the timeout be triggered by licking during the stimulus period itelf? Does Chris punish licks during the stimulus period? (Also, why is the response Window so long?)

Here's what I think I should do:

On unrewarded trials, licks during the stimulus period should trigger a timeout AFTER the end of the stimulus period.

Should the timeout really be triggered after only ONE lick? Or should there be some higher threshold?

If the animal doesn't lick during the stimulus period, then there should STILL be a post-stimulus response window. If the animal licks during this time, go to the timeout state immediately.

How long should I make this response window? Does it really need to be 45 seconds? 



##Thoughts on improvements 160505: How can we get object instantiations out of the main sketch? 

I've managed to accomplish this in MultiSens. There were two main things I had to do:

1) I defined a function in States.cpp that instantiates all of the state objects I need, puts pointers to them in an array, then returns the array (or more accurately, returns a pointer to the first element of the pointer array, which is equivalent to the array). I call this function from the main sketch to create an array of `TimedState` object pointers. This removes the need to explicitly instantiate each particular `TimedState` object at the beginning of `loop`.

Also, the main sketch makes some references to particular individual `TimedState` object constructors in `TRIAL_START` to reset the timers and update the durations for each object. I moved this functionality to `s_setup` for each `TimedState` object. `TimedState.s_setup()` executes automatically the first time `TimedState.run(time)` is called on a given trial. Moreover, `TimedState.run(time)` is called for all of the timed states that get executed on a given trial, so we're guaranteed that if a timed state gets executed, then its `run` function has been called, which means that its `s_setup` function has been called, which means that it has the most recent duration information from `param_values`. Thus, there's no need to call the constructor to do this from `TRIAL_START` in the main sketch.  

For convenience, in States.h, I use macros to define a number of indices into the states array so that I don't have to remember numeric indices for each state (in the same way that Chris used macros to define indices into `param_values`).

Then, in the main sketch, all references to particular `TimedState` objects are replaced with a reference to the states array along with the appropriate index. For example, 

    srw.run(time)

becomes

    states[stidx_RESPONSE_WINDOW]->run(time)     

However, calling functions from a `TimedState` pointer creates a problem with the `update` function, described below. 

2) `update` has to be changed to return nothing and take no arguments. As is, this is how `update` is defined in `TimedState`: virtual void `update`. However, `update` is then redefined with a new signature in States.cpp in several classes that inherit from `TimedState`. For example, in `TwoChoice`, we see `StateWaitForServoMove.update(Servo linServo)`, and `StateResponseWindow.update(uint16_int touched)`. 

Because these functions have different signatures from the one for `TimedState.update()`, they are not actually re-definitions of the `TimedState` virtual function. Rather, they are just regular functions of the inheriting class; they just happen to also be called update, but have no relation to `TimedState.update`.   

Moreover, it turns out that when we have our states array, its actual type is of pointer to the PARENT `TimedState` class. Even though the array includes pointers to objects that instantiate different inheriting classes `(StateWaitForServoMove, StateResponseWindow, etc.)`, each object ALSO instantiates the parent class TimedState, and THAT is the type that the pointers actually point to. 

Thus, when one tries to call 

    states[stidx]->update()

what you're actually calling is the TimedState function `update`, and NOT the `update` function of any of the inheriting classes. This means that `update` as used above must obey the syntax declared in `TimedState`, i.e., it takes nothing and returns void. If you try to pass it a `Servo` or `uint16_int`, you will get a compiler error saying that `TimedState` has no function called `update` that takes a `Servo` or a `uint16_int`.       

Given everything that `update` is intended to do currently, we can probably remove any arguments to it in the inheriting classes and keep it in conformity with the signature declared in TimedState.

For example, the `update` function of `StateResponseWindow` current takes the uint16_int variable touched as its input, then assigns the private variable `my_touched` to have the same value. In every case, however, the value of touched was just returned from a call to  `pollTouchInputs` earlier on in the main sketch. Could we just move the call to `pollTouchInputs` inside of `StateResponseWindow.update` and just have it return its value to `my_touched` directly?

The `update` function of `StateWaitForServoMove` takes a `Servo` object as its argument, then assigns it to a private variable `my_linServo` .  There's currently a comment in TwoChoice/States.cpp saying that this belongs in the constructor. We could try moving it there, but then we'd just have the same problem; the constructor can't take a `Servo` as an argument, because it needs to have the same signature as the `TimedState` constructor. But it seems that even the constructor shouldn't have to take a `Servo` object as an argument; we could declare linServo as extern in the global scope of States.cpp, then just assign `my_linServo = linServo` in the body of the constructor. 

One better would be to not just declare `linServo` as `extern` in the global scope of States.cpp, but to actually instantiate `linServo` in States.cpp and remove it from the main sketch. Currently, there are a few other references to `linServo` in the main sketch, but can these somehow be moved to States.cpp?    

In `INTER_TRIAL_INTERVAL`, we see `linServo.write(param_values[tpidx_SRV_FAR])`; it seems like we could wrap this line in a function that returns void and takes nothing, move the definition to States.cpp then just call that function from the main sketch. There are also a few lines that refer to `linServo` in `setup`, but it seems that these could also be moved to some `void servoSetup` function defined in States.cpp and just called from the main sketch. 
